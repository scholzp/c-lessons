\input{../templates/course_definitions}
\input{../templates/course_information}

\title{Debugging}
\subtitle{Variables}
\date{\today}



% the actual document
\begin{document}

\maketitle

%-------------------------------------------------------------------------------------------------

\begin{frame}{Contents}
	\tableofcontents
\end{frame}

%-------------------------------------------------------------------------------------------------
\section{Einleitung}
%-------------------------------------------------------------------------------------------------

\begin{frame}{It's not a bug...}
	Es gibt verschiede Arten von Bugs:
	\begin{itemize}
		\item Compiletime errors
		\item Runtime errors (\textit{bugs})
	\end{itemize}\ \\\ \\
	\textit{Compiletime errors}: Fehler die beim Compilieren auftreten. K\"onnen relative einfach behoben werden, da der Compiler auf sie hinweist.\\\ \\
	\textit{Bugs}: Treten während der Laufzeit (runtime) des Programms auf. Sie sind schwer zu finden und könnne schlimme Folgen haben.
\end{frame}

%-------------------------------------------------------------------------------------------------

\begin{frame}{... it's a feature.}
	Mögliche Auslöser von Bugs:
	\begin{itemize}
		\item Over- /underflow von Variablen
		\item Division durch Null 
		\item Unendliche Schleifen / Rekursion
		\item Range excess
		\item Segmentation fault
		\item Dereferenzierung von \textit{NULL pointers}
		\item und viele mehr
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------------------------

\begin{frame}{Tools für das Debugging}
	Nützliche und weitverbreitete Tools die zum Debugging eingesetzt werden sind:
	\begin{itemize}
		\item Der Compiler
		\item valgrind
		\item GDB
		\item strace (werden wir nicht ausprobieren, nur Hinweis auf Existenz)
	\end{itemize}
	Im folgenden sollen die Möglichkeiten deer Tools kurz angerissen werde.
\end{frame}

%-------------------------------------------------------------------------------------------------
\section{Debugging mit dem Compiler - am Beispiel der GCC}

%-------------------------------------------------------------------------------------------------

\begin{frame}{N\"utzliche Flags des GCC}
	Nützliche und weitverbreitete Tools die zum Debugging eingesetzt werden sind:
	\begin{itemize}
		\item -Wunsed (zeigt ungenutze Variable, gilt als Warnung)
		\item -Wall (zeigt [fast]alle Warnung)
		\item -Werror (behandelt Warnung als Fehler, so dass nicht compiliert wird)
		\item -g (default Debugging Informationen) 
		\item und viele mehr, siehe man gcc
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{Ein Test am Beispiel}
	Versucht einmal, das Programm der linked list wie folgt zu compilieren:
		\begin{lstlisting}[numbers=none]
$ gcc -Wall -Werror <Dateiname>.c\end{lstlisting}
Wenn ihr den Code nicht mehr habt, kopiert ihn euch \href{https://github.com/scholzp/c-lessons/blob/master/materials/memory_allocation/dynmamicMemeory.c}{hier}.
Die Ausgabe sollte wie folgt aussehen (wenn es eine Warnung gibt):
\\
\bigskip
\includegraphics[width = \linewidth]{../img/gccWerror.png}
\end{frame}

%-------------------------------------------------------------------------------------------------
\section{Vorbereitungen für Runtime Debugging}
%-------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{Vorbereitung}
	Normal kompilierten Programmen beinhalten sinnvollerweise keine bzw. wenige Debugginginformationen. Diese blähen die ausführbare Datei auf und bieten zusätzliche Angriffsfläche, da mit ihnen Reverse-Engeneering möglich ist.\\
	\bigskip
	Um Programme mit Debugging-Informationen zu compilieren:
		\begin{lstlisting}[numbers=none]
$ gcc -g <Dateiname>.c\end{lstlisting}
Falls \textit{GDB} noch nicht installiert ist, sollte dies noch getan werden:
		\begin{lstlisting}[numbers=none]
$ sudo pacman -S gdb        #arch
$ sudo apt-get install gdb  #ubuntu\end{lstlisting}

\end{frame}
%-------------------------------------------------------------------------------------------------
\section{Debugging mit GDB}
%-------------------------------------------------------------------------------------------------
\begin{frame}{GDB Befehle}
	\begin{itemize}
		\item Wenn gdb ohne ein Programm gestartet wurde kann mit \textbf{file}  \textit{file\_name} eine geladen werden.
		\item Mit \textbf{r[un]} kann das Programm innerhalb von gdb ausgeführt werden.\\
		Als ersten Schritt sollte das Programm so einmal abgearbeitet werden, um genauere Details zum Fehler zu erhalten.
		\item Haltepunkte (Breakpoints) können mit \textbf{b[reak]} \textit{line\_number} oder \textbf{b[reak]} \textit{function\_name} gesetzt werden.\\
		An der vermuteten Stelle des Bugs im Quelltext sollte begonnen werden.
		\item Mit \textbf{p[rint]} \textit{identifier} können Werte angezeigt werden.
		\item \textbf{w[atch]} \textit{identifier} unterbricht das Programm und gibt den Wert von \textit{identifier} aus, sobald diese Variable geändert wird.
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------------------------

\begin{frame}{Once you're at a breakpoint}
	\begin{itemize}
		\item \textbf{n[ext]} f\"uhrt nur die nächste Zeile des Prrgramms aus.
		\item \textbf{s[tep]} f\"urht die nächste Anweisung aus.
		\item Um das Programm bis zum n\"achsten Breakpoint ausführen zu lassen, kann \textbf{c[ontinue]} genutzt werden.
		\item Mit \textbf{backtrace} oder \textbf{bt} k\"onnen die aufgerufenen Funktionen angezeigt werden.\\
		Alle Funktionen die bis zum jetzigen Punk aufgerufen wurden, werden angezeigt.
		\\\ \\
		\item Wenn nur die \textit{Enter-Taste} gedrückt wird, wird der zuletzt eingegebene Befehl ausgeführt.
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------------------------

\begin{frame}[fragile]{Bedingte Haltepunkte (breakpoints)}
Nachdem ein Breakpoint gesetzt wurde, wird ihm von GDB eine ID zugewiesen.\\
Diese ID kann genutzt werden, um die Funktionalit\"at von diesem zu erweitern.
	\begin{itemize}
		\item \textbf{con[dition]} \textit{breakpoint\_ID expression} f\"ugt dem Breakpoint eine Bedingung hinzu:
		\begin{lstlisting}[numbers=none,language=bash]
(gdb) br 42
Breakpoint 1 at 0xbada55: file main.c, line 42.
(gdb) condition 1 i@=@@=@3
\end{lstlisting}
		\item Strings m\"ussen definiert werden, bevor sie mit \textbf{strcmp} genutzt werden k\"onnen:
		\begin{lstlisting}
(gdb) br main.c:42
Breakpoint 13 at 0xdeadbeef: file main.c, line 42.
(gdb) set $string_to_compare = "lolwut"
(gdb) cond 13 strcmp ( $stringtocompare, c ) @=@@=@ 0
\end{lstlisting}
	\end{itemize}
\end{frame}

%-------------------------------------------------------------------------------------------------
\begin{frame}{Eine kleine Zusammenfassung}
		\begin{tabular}{|l|l|}
			\hline
			\textbf{file} & L\"adt Programm\\\hline
			\textbf{r[un]} & F\"uhrt ein Programm aus\\\hline
			\textbf{b[reak]} & Setzt einen Breakpoint\\\hline
			\textbf{p[rint]} & Gibt Variable aus\\\hline
			\textbf{w[atch]} & Bei Ver\"anderung unterbreche und gebe Variable aus.\\\hline
			\textbf{n[ext]} & F\"uhre n\"achste Zeile aus und unterbreche\\\hline
			\textbf{s[tep]} & F\"uhre n\"achsten Befehl aus und unterbreche\\\hline
			\textbf{c[ontinue]} & F\"uhrt ein Programm bis zum n\"achsten Breakpoint aus\\\hline
			\textbf{backtrace} / \textbf{bt} & Gibt Aufrufhierarchi der Funktionen aus\\\hline
		\end{tabular}	
\end{frame}

%-------------------------------------------------------------------------------------------------
\begin{frame}{Ein kleines Beispiel}
Im Beispiel-Programm sind 2 kleine Fehler versteckt, die das Programm zum Absturz bringen. Versucht einmal, diese beiden Fehler mit GDB und dem Compiler zu finden. Hier eine Idee, wie man vorgehen könnte:
\begin{itemize}
 \item F\"uhrt das Programm einmal aus, um zu schauen, was der Fehler ist (es sollte abstürzen)
 \item Lasst euch einen Backtrace anzeigen, um die Funktionsaufrufe nachzuvollziehen.
 \item Wenn ihr verstanden habt, was nicht funktionieren könnte, lasst euch den Quelltext anzeigen. (Wenn nicht, meldet euch)
 \item Von hier aus solltet ihr alleine weiter kommen.
\end{itemize}
 Bitte nicht auf die n\"achste Folie schauen, da steht die Lösung. 
\end{frame}
%-------------------------------------------------------------------------------------------------

\begin{frame}[fragile]{Und die Aufl\"osung}
Beide Fehler sind in dieser kleinen Funktion:
\begin{lstlisting}
void a(int n){
  if(n = 0)
    return;
  a(n);
}\end{lstlisting}
In main() wird d(), in d() wird c(), in c() wird b() und in d() wird a() aufgerufen. Die Funktion a() ruft sich selbst rekursiv auf. Sie hat folgende Fehler, die zu einer unendlichen Rekursion und damit wegen ausgehenden Stackspeicher zu einem Absturz f\"uhren:\\
In Zeile 2: Kein Vergleich, sondern Zuweisung. Sollte n == 0. sein\\
In Zeile 4: Kein Dekrementieren um Abbruchbedingungen zu erreichen. Sollte a(n-1) sein.
\end{frame}
%-------------------------------------------------------------------------------------------------
\section{Debugging mit valgrind}

\end{document}
